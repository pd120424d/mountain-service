name: Deploy to Kubernetes

on:
  push:
    branches: [ main ]
    paths:
      - 'api/**'
      - 'ui/**'
      - 'k8s/**'
      - '.github/workflows/k8s-deploy.yml'

jobs:
  deploy:
    runs-on: self-hosted
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Prepare local kubeconfig (self-hosted runner)
        run: |
          mkdir -p ~/.kube
          if [ -f /etc/rancher/k3s/k3s.yaml ]; then
            sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            sudo chown "$USER:$USER" ~/.kube/config
            # Force local API server for self-hosted runner to avoid public IP hairpin/firewall issues
            sed -E -i 's#^([[:space:]]*)server:.*#\1server: https://127.0.0.1:6443#' ~/.kube/config || true
            echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          else
            echo "k3s kubeconfig not found at /etc/rancher/k3s/k3s.yaml" >&2
            exit 1
          fi


      - name: Ensure namespace exists
        run: |
          kubectl apply -f k8s/namespaces.yaml

      - name: Create/Update GHCR image pull secret
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          kubectl -n mountain create secret docker-registry ghcr-auth \
            --docker-server=ghcr.io \
            --docker-username="$GITHUB_ACTOR" \
            --docker-password="$GHCR_PAT" \
            --dry-run=client -o yaml | kubectl apply -f -


      - name: Create/Update Secrets - DB Common (User/Port)
        run: |
          kubectl -n mountain create secret generic db-common \
            --from-literal=DB_USER='${{ secrets.DB_USER }}' \
            --from-literal=DB_PORT='${{ secrets.DB_PORT }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Employee DB
        run: |
          kubectl -n mountain create secret generic employee-db \
            --from-literal=DB_HOST='${{ secrets.EMPLOYEE_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.EMPLOYEE_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.EMPLOYEE_DB_NAME }}' \
            --from-literal=DB_SSLMODE='${{ secrets.EMPLOYEE_DB_SSLMODE }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Urgency DB
        run: |
          kubectl -n mountain create secret generic urgency-db \
            --from-literal=DB_HOST='${{ secrets.URGENCY_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.URGENCY_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.URGENCY_DB_NAME }}' \
            --from-literal=DB_SSLMODE='${{ secrets.URGENCY_DB_SSLMODE }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Activity DB
        run: |
          kubectl -n mountain create secret generic activity-db \
            --from-literal=DB_HOST='${{ secrets.ACTIVITY_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.ACTIVITY_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.ACTIVITY_DB_NAME }}' \
            --from-literal=DB_SSLMODE="${{ secrets.ACTIVITY_DB_SSLMODE }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - App Shared
        run: |
          kubectl -n mountain create secret generic app-shared \
            --from-literal=JWT_SECRET='${{ secrets.JWT_SECRET }}' \
            --from-literal=ADMIN_PASSWORD='${{ secrets.ADMIN_PASSWORD }}' \
            --from-literal=SERVICE_AUTH_SECRET='${{ secrets.SERVICE_AUTH_SECRET }}' \
            --from-literal=CORS_ALLOWED_ORIGINS='${{ secrets.CORS_ALLOWED_ORIGINS }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Azure Storage
        run: |
          kubectl -n mountain create secret generic azure-storage \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME='${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}' \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY='${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}' \
            --from-literal=AZURE_STORAGE_CONTAINER_NAME='${{ secrets.AZURE_STORAGE_CONTAINER_NAME }}' \
            --dry-run=client -o yaml | kubectl apply -f -


      - name: (Optional) Create/Update Secrets - GCP Service Account
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
        if: ${{ env.GCP_SA_KEY != '' }}
        run: |
          echo "$GCP_SA_KEY" > sa.json
          kubectl -n mountain create secret generic gcp-sa \
            --from-file=key.json=sa.json \
            --from-literal=GCP_PROJECT_ID="$GCP_PROJECT_ID" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: (Optional) Create/Update Secrets - Cloud SQL Instance Names
        env:
          CLOUDSQL_INSTANCE_EMPLOYEE: ${{ secrets.CLOUDSQL_INSTANCE_EMPLOYEE }}
          CLOUDSQL_INSTANCE_URGENCY: ${{ secrets.CLOUDSQL_INSTANCE_URGENCY }}
          CLOUDSQL_INSTANCE_ACTIVITY: ${{ secrets.CLOUDSQL_INSTANCE_ACTIVITY }}
        if: ${{ env.CLOUDSQL_INSTANCE_EMPLOYEE != '' || env.CLOUDSQL_INSTANCE_URGENCY != '' || env.CLOUDSQL_INSTANCE_ACTIVITY != '' }}
        run: |
          if [ -n "$CLOUDSQL_INSTANCE_EMPLOYEE" ]; then
            kubectl -n mountain create secret generic cloudsql-employee \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_EMPLOYEE" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_INSTANCE_URGENCY" ]; then
            kubectl -n mountain create secret generic cloudsql-urgency \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_URGENCY" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_INSTANCE_ACTIVITY" ]; then
            kubectl -n mountain create secret generic cloudsql-activity \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_ACTIVITY" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

      - name: Apply manifests
        run: |
          kubectl apply -f k8s/namespaces.yaml
          kubectl -n mountain apply -f k8s/deployments/
          kubectl -n mountain apply -f k8s/services/
          kubectl -n mountain apply -f k8s/frontend/

      - name: "Post-apply: show pods and imagePullSecrets"
        run: |
          echo "Pods (wide):"
          kubectl -n mountain get pods -o wide || true
          echo "\nRecent events (last 200 lines):"
          kubectl -n mountain get events --sort-by=.lastTimestamp | tail -n 200 || true
          echo "\nDescribe deployments (images + imagePullSecrets):"
          for d in employee-service urgency-service activity-service version-service; do
            echo "\n--- DESCRIBE DEPLOYMENT: $d ---"
            kubectl -n mountain describe deploy "$d" | sed -n '/Image:/,/Environment:/p' || true
            echo "\nImagePullSecrets:"
            kubectl -n mountain get deploy "$d" -o jsonpath='{.spec.template.spec.imagePullSecrets}' || true
            echo "\nImages:"
            kubectl -n mountain get deploy "$d" -o jsonpath='{range .spec.template.spec.containers[*]}{.name}:{.image}{"\n"}{end}' || true
            echo "\n---\n"
          done
          echo "\nIf any pods are in ImagePullBackOff, try:\n  kubectl -n mountain describe pod <pod-name>\n"


