name: Build, Test & Deploy

on:
  push:
    branches: [ main ]
    paths:
      - 'api/**'
      - 'ui/**'
      - 'k8s/**'
      - '.github/workflows/build-test-deploy.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: "Force rebuild and redeploy all services (ignore change detection)"
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      ui-changed: ${{ steps.changes.outputs.ui }}
      api-changed: ${{ steps.changes.outputs.api }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changes
        id: changes
        run: |
          echo "ui=$(git diff --name-only HEAD~1 HEAD | grep -q '^ui/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "api=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "UI changed: $(git diff --name-only HEAD~1 HEAD | grep -q '^ui/' && echo 'true' || echo 'false')"
          echo "API changed: $(git diff --name-only HEAD~1 HEAD | grep -q '^api/' && echo 'true' || echo 'false')"

  test-frontend:
    runs-on: ubuntu-latest
    needs: detect-changes
    defaults:
      run:
        working-directory: ui
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if frontend tests should run
        id: should-run
        run: |
          FORCE=false
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ] || git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          if [ "${{ needs.detect-changes.outputs.ui-changed }}" = "true" ] || [ "$FORCE" = "true" ]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Frontend tests will run (UI changes detected or force deploy)"
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "Frontend tests will be skipped (no UI changes detected)"
          fi

      - name: Setup Node.js
        if: steps.should-run.outputs.should-run == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ui/package-lock.json

      - name: Install dependencies
        if: steps.should-run.outputs.should-run == 'true'
        run: npm ci

      - name: Run tests with coverage
        if: steps.should-run.outputs.should-run == 'true'
        run: npm test

      - name: Check coverage threshold
        if: steps.should-run.outputs.should-run == 'true'
        run: |
          COVERAGE=$(node -e "console.log(JSON.parse(require('fs').readFileSync('./coverage/ui/coverage-summary.json')).total.statements.pct)")
          echo "Frontend coverage: ${COVERAGE}%"
          if (( $(echo "$COVERAGE < 75" | bc -l) )); then
            echo "FAILURE: Frontend coverage ${COVERAGE}% is below 75% threshold"
            exit 1
          fi
          echo "SUCCESS: Frontend coverage ${COVERAGE}% meets threshold"

  test-backend:
    runs-on: ubuntu-latest
    needs: detect-changes
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if backend tests should run
        id: should-run
        run: |
          FORCE=false
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ] || git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          if [ "${{ needs.detect-changes.outputs.api-changed }}" = "true" ] || [ "$FORCE" = "true" ]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "Backend tests will run (API changes detected or force deploy)"
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "Backend tests will be skipped (no API changes detected)"
          fi

      - name: Setup Go
        if: steps.should-run.outputs.should-run == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.1'
          cache-dependency-path: api/go.sum

      - name: Install go-acc
        if: steps.should-run.outputs.should-run == 'true'
        run: go install github.com/ory/go-acc@latest

      - name: Run backend coverage tests
        if: steps.should-run.outputs.should-run == 'true'
        env:
          VERBOSE: '1'
          TIMEOUT_SECONDS: '900'
        run: ./backend-test-cover.sh all --threshold=75

  build-ui:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push UI image
        if: needs.detect-changes.outputs.ui-changed == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd ui
          docker build -f Dockerfile \
                       -t ghcr.io/pd120424d/mountain-ui:${{ github.sha }} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --build-arg NGINX_CONFIG=production \
                       --no-cache .
          docker push ghcr.io/pd120424d/mountain-ui:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ needs.detect-changes.outputs.ui-changed }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-employee:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect employee changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/employee/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "contracts=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/contracts/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Employee service
        if: steps.changes.outputs.changed == 'true' || steps.changes.outputs.contracts == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd api
          docker build -f employee/Dockerfile \
                       -t ghcr.io/pd120424d/employee-service:${{ github.sha }} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --build-arg SWAGGER_HOST=mountain-service.duckdns.org \
                       --no-cache .
          docker push ghcr.io/pd120424d/employee-service:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.changes.outputs.contracts }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-urgency:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect urgency changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/urgency/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "contracts=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/contracts/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Urgency service
        if: steps.changes.outputs.changed == 'true' || steps.changes.outputs.contracts == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd api
          docker build -f urgency/Dockerfile \
                       -t ghcr.io/pd120424d/urgency-service:${{ github.sha }} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --build-arg SWAGGER_HOST=mountain-service.duckdns.org \
                       --no-cache .
          docker push ghcr.io/pd120424d/urgency-service:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.changes.outputs.contracts }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-activity:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect activity changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/activity/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "contracts=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/contracts/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Activity service (with CQRS support)
        if: steps.changes.outputs.changed == 'true' || steps.changes.outputs.contracts == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd api
          docker build -f activity/Dockerfile \
                       -t ghcr.io/pd120424d/activity-service:${{ github.sha }} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --build-arg SWAGGER_HOST=mountain-service.duckdns.org \
                       --no-cache .
          docker push ghcr.io/pd120424d/activity-service:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.changes.outputs.contracts }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-activity-updater:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect updater changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/activity-readmodel-updater/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Activity Read Model Updater service
        if: steps.changes.outputs.changed == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd api
          docker build -f activity-readmodel-updater/Dockerfile \
                       -t ghcr.io/pd120424d/activity-readmodel-updater:${{ github.sha }} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --no-cache .
          docker push ghcr.io/pd120424d/activity-readmodel-updater:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-version:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect version service changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/version-service/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Version service
        if: steps.changes.outputs.changed == 'true' || steps.force.outputs.force == 'true'
        run: |
          git fetch --tags --force --prune
          cd api
          GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          SHORT_SHA=$(git rev-parse --short=8 HEAD)
          VERSION_ARG=${GIT_TAG:-$SHORT_SHA}
          docker build -f version-service/Dockerfile \
                       -t ghcr.io/pd120424d/version-service:${{ github.sha }} \
                       --build-arg VERSION=${VERSION_ARG} \
                       --build-arg GIT_SHA=${SHORT_SHA} \
                       --build-arg GIT_TAG=${GIT_TAG} \
                       --build-arg BUILD_TIMESTAMP=$(date +%s) \
                       --build-arg GIT_COMMIT_SHA=${{ github.sha }} \
                       --no-cache .
          docker push ghcr.io/pd120424d/version-service:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  build-docs-aggregator:
    runs-on: ubuntu-latest
    needs: [detect-changes, test-frontend, test-backend]
    if: always() && (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') && (needs.test-backend.result == 'success' || needs.test-backend.result == 'skipped')
    permissions:
      contents: read
      packages: write
    outputs:
      built: ${{ steps.set-built.outputs.built }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Detect docs-aggregator changes
        id: changes
        run: |
          echo "changed=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/docs-aggregator/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "contracts=$(git diff --name-only HEAD~1 HEAD | grep -q '^api/contracts/' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Determine force rebuild
        id: force
        run: |
          FORCE=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then FORCE=true; fi
          if git log -1 --pretty=%B | grep -qiE 'force[ _-]?rebuild|force[ _-]?deploy|rebuild all'; then FORCE=true; fi
          echo "force=${FORCE}" >> $GITHUB_OUTPUT

      - name: Build and push Docs Aggregator
        if: steps.changes.outputs.changed == 'true' || steps.changes.outputs.contracts == 'true' || steps.force.outputs.force == 'true'
        run: |
          cd api
          docker build -f docs-aggregator/Dockerfile \
                       -t ghcr.io/pd120424d/docs-aggregator:${{ github.sha }} \
                       --no-cache .
          docker push ghcr.io/pd120424d/docs-aggregator:${{ github.sha }}

      - id: set-built
        run: |
          if [ "${{ steps.changes.outputs.changed }}" = "true" ] || [ "${{ steps.changes.outputs.contracts }}" = "true" ] || [ "${{ steps.force.outputs.force }}" = "true" ]; then
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

  deploy-k8s:
    runs-on: self-hosted
    needs: [detect-changes, build-ui, build-employee, build-urgency, build-activity, build-activity-updater, build-version, build-docs-aggregator]
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Prepare local kubeconfig (self-hosted runner)
        run: |
          mkdir -p ~/.kube
          if [ -f /etc/rancher/k3s/k3s.yaml ]; then
            SRC=$(readlink -f /etc/rancher/k3s/k3s.yaml)
            DEST=$(readlink -f ~/.kube/config || echo ~/.kube/config)
            if [ "$SRC" = "$DEST" ]; then
              echo "k3s kubeconfig already at ~/.kube/config; skipping copy"
            else
              sudo cp "$SRC" ~/.kube/config
              sudo chown "$USER:$USER" ~/.kube/config
            fi
            # Force local API server for self-hosted runner to avoid public IP hairpin/firewall issues
            sed -E -i 's#^([[:space:]]*)server:.*#\1server: https://127.0.0.1:6443#' ~/.kube/config || true
            echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          else
            echo "k3s kubeconfig not found at /etc/rancher/k3s/k3s.yaml" >&2
            exit 1
          fi


      - name: Ensure namespace exists
        run: |
          kubectl apply -f k8s/namespaces.yaml

      - name: Create/Update GHCR image pull secret
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          kubectl -n mountain-service create secret docker-registry ghcr-auth \
            --docker-server=ghcr.io \
            --docker-username="$GITHUB_ACTOR" \
            --docker-password="$GHCR_PAT" \
            --dry-run=client -o yaml | kubectl apply -f -


      - name: Create/Update Secrets - DB Common (User/Port)
        run: |
          kubectl -n mountain-service create secret generic db-common \
            --from-literal=DB_USER='${{ secrets.DB_USER }}' \
            --from-literal=DB_PORT='${{ secrets.DB_PORT }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Employee DB
        run: |
          kubectl -n mountain-service create secret generic employee-db \
            --from-literal=DB_HOST='${{ secrets.EMPLOYEE_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.EMPLOYEE_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.EMPLOYEE_DB_NAME }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Urgency DB
        run: |
          kubectl -n mountain-service create secret generic urgency-db \
            --from-literal=DB_HOST='${{ secrets.URGENCY_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.URGENCY_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.URGENCY_DB_NAME }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Activity DB
        run: |
          kubectl -n mountain-service create secret generic activity-db \
            --from-literal=DB_HOST='${{ secrets.ACTIVITY_DB_HOST }}' \
            --from-literal=DB_PASSWORD='${{ secrets.ACTIVITY_DB_PASSWORD }}' \
            --from-literal=DB_NAME='${{ secrets.ACTIVITY_DB_NAME }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - GCP CQRS Keys
        run: |
          # Create GCP service account secrets for CQRS
          set -euo pipefail

          printf "%s" '${{ secrets.GCP_ACTIVITY_KEY }}' > /tmp/activity-api-key.json
          printf "%s" '${{ secrets.GCP_READMODEL_UPDATER_KEY }}' > /tmp/activity-updater-key.json

          # Fail fast if secrets are missing/empty
          [ $(wc -c < /tmp/activity-api-key.json) -gt 100 ] || { echo "Activity key empty or too small"; exit 1; }
          [ $(wc -c < /tmp/activity-updater-key.json) -gt 100 ] || { echo "Updater key empty or too small"; exit 1; }
          grep -q '"client_email"' /tmp/activity-api-key.json || { echo "Activity key malformed"; exit 1; }
          grep -q '"client_email"' /tmp/activity-updater-key.json || { echo "Updater key malformed"; exit 1; }

          kubectl -n mountain-service create secret generic gcp-activity-api-key \
            --from-file=key.json=/tmp/activity-api-key.json \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl -n mountain-service create secret generic gcp-readmodel-updater-key \
            --from-file=key.json=/tmp/activity-updater-key.json \
            --dry-run=client -o yaml | kubectl apply -f -

          # Clean up temp files
          rm -f /tmp/activity-api-key.json /tmp/activity-updater-key.json


      - name: Create/Update Secret - GCP Logging Writer
        env:
          GCP_LOGGING_WRITER_KEY: ${{ secrets.GCP_LOGGING_WRITER_KEY }}
        if: ${{ env.GCP_LOGGING_WRITER_KEY != '' }}
        run: |
          set -euo pipefail
          echo 'Creating gcp-logging-writer-key secret from GitHub secret...'
          printf "%s" "$GCP_LOGGING_WRITER_KEY" > /tmp/ms-logger.json
          [ $(wc -c < /tmp/ms-logger.json) -gt 100 ] || { echo "Logging writer key empty or too small"; exit 1; }
          grep -q '"client_email"' /tmp/ms-logger.json || { echo "Logging writer key malformed"; exit 1; }

          kubectl -n mountain-service create secret generic gcp-logging-writer-key \
            --from-file=key.json=/tmp/ms-logger.json \
            --dry-run=client -o yaml | kubectl apply -f -

          rm -f /tmp/ms-logger.json

      - name: Create/Update Secrets - App Shared
        run: |
          kubectl -n mountain-service create secret generic app-shared \
            --from-literal=JWT_SECRET='${{ secrets.JWT_SECRET }}' \
            --from-literal=ADMIN_PASSWORD='${{ secrets.ADMIN_PASSWORD }}' \
            --from-literal=SERVICE_AUTH_SECRET='${{ secrets.SERVICE_AUTH_SECRET }}' \
            --from-literal=CORS_ALLOWED_ORIGINS='${{ secrets.CORS_ALLOWED_ORIGINS }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets - Azure Storage
        run: |
          kubectl -n mountain-service create secret generic azure-storage \
            --from-literal=AZURE_STORAGE_ACCOUNT_NAME='${{ secrets.AZURE_STORAGE_ACCOUNT_NAME }}' \
            --from-literal=AZURE_STORAGE_ACCOUNT_KEY='${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}' \
            --from-literal=AZURE_STORAGE_CONTAINER_NAME='${{ secrets.AZURE_STORAGE_CONTAINER_NAME }}' \
            --dry-run=client -o yaml | kubectl apply -f -


      - name: Create/Update Secrets - GCP Service Account
        env:
          GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
        if: ${{ env.GCP_SA_KEY != '' }}
        run: |
          echo 'GCP_SA_KEY is set, creating GCP SA secret...'
          echo "$GCP_SA_KEY" | grep email
          echo "$GCP_SA_KEY" > sa.json
          kubectl -n mountain-service create secret generic gcp-sa \
            --from-file=key.json=sa.json \
            --from-literal=GCP_PROJECT_ID="$GCP_PROJECT_ID" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: (Optional) Create/Update Secrets - Cloud SQL Instance Names
        env:
          CLOUDSQL_INSTANCE_EMPLOYEE: ${{ secrets.CLOUDSQL_INSTANCE_EMPLOYEE }}
          CLOUDSQL_INSTANCE_URGENCY: ${{ secrets.CLOUDSQL_INSTANCE_URGENCY }}
          CLOUDSQL_INSTANCE_ACTIVITY: ${{ secrets.CLOUDSQL_INSTANCE_ACTIVITY }}
        if: ${{ env.CLOUDSQL_INSTANCE_EMPLOYEE != '' || env.CLOUDSQL_INSTANCE_URGENCY != '' || env.CLOUDSQL_INSTANCE_ACTIVITY != '' }}
        run: |
          if [ -n "$CLOUDSQL_INSTANCE_EMPLOYEE" ]; then
            kubectl -n mountain-service create secret generic cloudsql-employee \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_EMPLOYEE" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_INSTANCE_URGENCY" ]; then
            kubectl -n mountain-service create secret generic cloudsql-urgency \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_URGENCY" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_INSTANCE_ACTIVITY" ]; then
            kubectl -n mountain-service create secret generic cloudsql-activity \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_INSTANCE_ACTIVITY" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi


      - name: (Optional) Create/Update Secrets - Cloud SQL Replica Instance Names
        env:
          CLOUDSQL_REPLICAS_URGENCY_1: ${{ secrets.CLOUDSQL_REPLICAS_URGENCY_1 }}
          CLOUDSQL_REPLICAS_URGENCY_2: ${{ secrets.CLOUDSQL_REPLICAS_URGENCY_2 }}
          CLOUDSQL_REPLICAS_EMPLOYEE_1: ${{ secrets.CLOUDSQL_REPLICAS_EMPLOYEE_1 }}
          CLOUDSQL_REPLICAS_EMPLOYEE_2: ${{ secrets.CLOUDSQL_REPLICAS_EMPLOYEE_2 }}
        run: |
          if [ -n "$CLOUDSQL_REPLICAS_URGENCY_1" ]; then
            kubectl -n mountain-service create secret generic cloudsql-urgency-replica1 \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_REPLICAS_URGENCY_1" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_REPLICAS_URGENCY_2" ]; then
            kubectl -n mountain-service create secret generic cloudsql-urgency-replica2 \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_REPLICAS_URGENCY_2" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_REPLICAS_EMPLOYEE_1" ]; then
            kubectl -n mountain-service create secret generic cloudsql-employee-replica1 \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_REPLICAS_EMPLOYEE_1" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi
          if [ -n "$CLOUDSQL_REPLICAS_EMPLOYEE_2" ]; then
            kubectl -n mountain-service create secret generic cloudsql-employee-replica2 \
              --from-literal=INSTANCE_CONNECTION_NAME="$CLOUDSQL_REPLICAS_EMPLOYEE_2" \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

      - name: Remove legacy Ingress objects (first run only; ignore if missing)
        run: |
          kubectl -n mountain-service delete ingress activity-service version-service docs-aggregator urgency-service || true


      - name: Remove Fluent Bit completely (cleanup)
        run: |
          # Remove Helm-managed Fluent Bit
          helm uninstall fluent-bit-frontend -n mountain-service || true
          # Remove legacy Fluent Bit objects
          kubectl -n mountain-service delete daemonset fluent-bit-frontend || true
          kubectl -n mountain-service delete configmap fluent-bit-config fluent-bit-frontend-config || true
          kubectl -n mountain-service delete serviceaccount fluent-bit-sa fluent-bit-frontend || true
          kubectl delete clusterrolebinding fluent-bit-binding fluent-bit-frontend || true
          kubectl delete clusterrole fluent-bit-role fluent-bit-frontend || true

      - name: Prepare charts directory (prefer repo ./charts or ./api/charts; fallback to VM user home)
        env:
          VM_USER: ${{ secrets.K8S_VM_USER }}
        run: |
          set -euo pipefail
          if [ -d ./charts ]; then
            echo "Using charts from repository ./charts"
          elif [ -d ./api/charts ]; then
            echo "Seeding ./charts from repository ./api/charts..."
            mkdir -p ./charts
            cp -a ./api/charts/. ./charts/
            ls -la ./charts
          elif [ -n "${VM_USER:-}" ] && [ -d "/home/$VM_USER/charts" ]; then
            echo "Syncing charts from VM home directory into workspace ./charts..."
            mkdir -p ./charts
            cp -a "/home/$VM_USER/charts/." ./charts/
            echo "Charts copied. Contents:"
            ls -la ./charts
          else
            echo "ERROR: No charts directory found (neither ./charts nor ./api/charts nor /home/<VM_USER>/charts)." >&2
            exit 1
          fi


      - name: Deploy services via Helm (Ingress + rollout managed by charts)
        run: |
          set -euo pipefail
          NS=mountain-service
          HOST=mountain-service.duckdns.org
          SHA=${GITHUB_SHA:-${{ github.sha }}}

          # Built flags from build jobs (true iff image was built and pushed in this run)
          UI_BUILT="${{ needs.build-ui.outputs.built || 'false' }}"
          EMP_BUILT="${{ needs.build-employee.outputs.built || 'false' }}"
          URG_BUILT="${{ needs.build-urgency.outputs.built || 'false' }}"
          ACT_BUILT="${{ needs.build-activity.outputs.built || 'false' }}"
          ACTU_BUILT="${{ needs.build-activity-updater.outputs.built || 'false' }}"
          VER_BUILT="${{ needs.build-version.outputs.built || 'false' }}"
          DOCSAGG_BUILT="${{ needs.build-docs-aggregator.outputs.built || 'false' }}"

          current_image() {
            local deploy_name="$1"
            kubectl -n "$NS" get deploy "$deploy_name" -o=jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "unknown"
          }

          print_state() {
            local release="$1" deploy_name="$2"
            echo "[$release] Helm values (image section):"
            helm -n "$NS" get values "$release" -o yaml | sed -n '/^image:/,/^[^ ]/p' || true
            echo "[$release] Current deployment image: $(current_image "$deploy_name")"
          }

          guard_no_latest() {
            local release="$1" deploy_name="$2" built_flag="$3" set_tag="$4"
            # If a new image will be set in this run, skip the guard
            if [[ "$set_tag" == "true" && "$built_flag" == "true" ]]; then
              return 0
            fi
            local img
            img=$(current_image "$deploy_name")
            if [[ "$img" == *":latest" ]]; then
              echo "ERROR: [$release] deployment image uses ':latest' (img=$img). Refusing to proceed for unchanged service."
              echo "HINT: Rebuild this service to pin a SHA tag, or set image.tag via Helm to a specific SHA."
              exit 1
            fi
          }

          upgrade() {
            local release="$1" chart="$2" deploy_name="$3" built_flag="$4" set_tag="$5"
            local flags="--atomic --timeout 10m"
            if [[ "$set_tag" == "true" && "$built_flag" == "true" ]]; then
              echo "[$release] setting image.tag=$SHA (built in this run)"
              helm upgrade --install "$release" "$chart" -n "$NS" $flags --reuse-values --set image.tag=$SHA
            else
              echo "[$release] no new image built; applying chart changes with existing values (no tag change)"
              helm upgrade --install "$release" "$chart" -n "$NS" $flags --reuse-values
            fi
            kubectl -n "$NS" rollout status "deploy/$deploy_name" --timeout=300s
            echo "[$release] Post-upgrade deployment image: $(current_image "$deploy_name")"
          }

          echo "Upgrading Frontend via Helm..."
          print_state frontend frontend
          upgrade frontend ./charts/frontend frontend "$UI_BUILT" true

          echo "Upgrading Employee service via Helm..."
          print_state employee-service employee-service
          guard_no_latest employee-service employee-service "$EMP_BUILT" true
          upgrade employee-service ./charts/employee-service employee-service "$EMP_BUILT" true

          echo "Upgrading Urgency service via Helm..."
          print_state urgency-service urgency-service
          guard_no_latest urgency-service urgency-service "$URG_BUILT" true
          upgrade urgency-service ./charts/urgency-service urgency-service "$URG_BUILT" true

          echo "Upgrading Activity service via Helm..."
          print_state activity-service activity-service
          guard_no_latest activity-service activity-service "$ACT_BUILT" true
          upgrade activity-service ./charts/activity-service activity-service "$ACT_BUILT" true

          echo "Upgrading Activity Readmodel Updater via Helm..."
          print_state activity-readmodel-updater activity-readmodel-updater
          guard_no_latest activity-readmodel-updater activity-readmodel-updater "$ACTU_BUILT" true
          upgrade activity-readmodel-updater ./charts/activity-readmodel-updater activity-readmodel-updater "$ACTU_BUILT" true

          echo "Upgrading Version service via Helm..."
          print_state version-service version-service
          guard_no_latest version-service version-service "$VER_BUILT" true
          upgrade version-service ./charts/version-service version-service "$VER_BUILT" true

          echo "Upgrading Docs Aggregator via Helm..."
          print_state docs-aggregator docs-aggregator
          guard_no_latest docs-aggregator docs-aggregator "$DOCSAGG_BUILT" true
          upgrade docs-aggregator ./charts/docs-aggregator docs-aggregator "$DOCSAGG_BUILT" true

          echo "Upgrading Docs UI via Helm... (no tag pinning)"
          print_state docs-ui docs-ui
          upgrade docs-ui ./charts/docs-ui docs-ui "false" false


      - name: Show status and recent events
        run: |
          echo "Pods (wide):"
          kubectl -n mountain-service get pods -o wide || true
          echo "\nRecent events (last 200 lines):"
          kubectl -n mountain-service get events --sort-by=.lastTimestamp | tail -n 200 || true

      - name: Ingress smoke checks
        run: |
          set -euo pipefail
          HOST=mountain-service.duckdns.org
          echo "Checking ingress endpoints..."
          curl -fsS "http://$HOST/api/v1/health" >/dev/null || echo "health endpoint not centralized; skipping strict fail"
          curl -fsS "http://$HOST/api/v1/docs" >/dev/null
