name: Multi-Cloud Deployment

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      deployment_target:
        description: 'Deployment target (azure or aws)'
        required: true
        default: 'aws'
        type: choice
        options:
          - azure
          - aws
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  get-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
      git_sha: ${{ steps.version.outputs.GIT_SHA }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Fetch full git history and tags
      run: |
        git fetch --tags --unshallow || git fetch --tags

    - name: Get Git tag and SHA
      id: version
      run: |
        echo "VERSION=$(git describe --tags --abbrev=0 --match "v*" 2>/dev/null || echo dev)" >> $GITHUB_OUTPUT
        echo "GIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

  build-backend:
    needs: get-version
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        service:
          - name: employee-service
            dockerfile: ./api/employee/Dockerfile
            context: ./api
            build_args: ""
          - name: urgency-service
            dockerfile: ./api/urgency/Dockerfile
            context: ./api
            build_args: ""
          - name: activity-service
            dockerfile: ./api/activity/Dockerfile
            context: ./api
            build_args: ""
          - name: version-service
            dockerfile: ./api/version-service/Dockerfile
            context: ./api
            build_args: "VERSION GIT_SHA"

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      run: echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    - name: Clean Docker build cache
      run: |
        echo "Cleaning Docker build cache to ensure fresh build..."
        docker builder prune -f
        docker system prune -f

    - name: Determine deployment target
      id: deployment-target
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "target=${{ github.event.inputs.deployment_target }}" >> $GITHUB_OUTPUT
        else
          echo "target=${{ secrets.AWS_DEPLOYMENT_TARGET || 'aws' }}" >> $GITHUB_OUTPUT
        fi

    - name: Set up environment variables
      run: |
        TARGET="${{ steps.deployment-target.outputs.target }}"
        echo "DEPLOYMENT_TARGET=$TARGET" >> $GITHUB_ENV

        if [ "$TARGET" = "aws" ]; then
          # Use AWS-prefixed secrets
          echo "CLOUD_INSTANCE_IP=${{ secrets.AWS_INSTANCE_IP }}" >> $GITHUB_ENV
          echo "CLOUD_INSTANCE_USER=${{ secrets.AWS_INSTANCE_USER }}" >> $GITHUB_ENV
          echo "JWT_SECRET=${{ secrets.AWS_JWT_SECRET }}" >> $GITHUB_ENV
          echo "ADMIN_PASSWORD=${{ secrets.AWS_ADMIN_PASSWORD }}" >> $GITHUB_ENV
          echo "SERVICE_AUTH_SECRET=${{ secrets.AWS_SERVICE_AUTH_SECRET }}" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=${{ secrets.AWS_CORS_ALLOWED_ORIGINS }}" >> $GITHUB_ENV
          echo "DB_USER=${{ secrets.AWS_DB_USER }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.AWS_DB_PASSWORD }}" >> $GITHUB_ENV
          echo "COMPOSE_ENV=production" >> $GITHUB_ENV
          echo "SWAGGER_API_URL=http://${{ secrets.AWS_INSTANCE_IP }}:8082/swagger.json" >> $GITHUB_ENV
        else
          # Use existing Azure secrets (backward compatibility)
          echo "CLOUD_INSTANCE_IP=${{ secrets.AZURE_VM_HOST }}" >> $GITHUB_ENV
          echo "CLOUD_INSTANCE_USER=${{ secrets.AZURE_VM_USER }}" >> $GITHUB_ENV
          echo "JWT_SECRET=${{ secrets.JWT_SECRET || 'default-jwt-secret' }}" >> $GITHUB_ENV
          echo "ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD || 'admin123' }}" >> $GITHUB_ENV
          echo "SERVICE_AUTH_SECRET=${{ secrets.SERVICE_AUTH_SECRET || 'default-service-secret' }}" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS || 'http://localhost' }}" >> $GITHUB_ENV
          echo "DB_USER=${{ secrets.DB_USER }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          echo "COMPOSE_ENV=${{ secrets.COMPOSE_ENV }}" >> $GITHUB_ENV
          echo "SWAGGER_API_URL=${{ secrets.SWAGGER_API_URL }}" >> $GITHUB_ENV
        fi
        
        # Set image names (matching working backend-deploy.yml pattern)
        echo "EMPLOYEE_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/employee-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "URGENCY_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/urgency-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "ACTIVITY_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/activity-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "VERSION_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/version-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "FRONTEND_IMAGE=ghcr.io/${{ github.repository_owner }}/frontend:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV

    - name: Build Docker image for ${{ matrix.service.name }}
      run: |
        # Always use --no-cache for now to ensure we get the new code structure
        NO_CACHE_FLAG="--no-cache"

        # Also add a unique build arg to bust cache completely
        BUILD_TIMESTAMP=$(date +%s)

        if [ "${{ matrix.service.build_args }}" != "" ]; then
          docker build \
            -f ${{ matrix.service.dockerfile }} \
            -t ${{ matrix.service.name }}:latest \
            --build-arg VERSION=${{ needs.get-version.outputs.version }} \
            --build-arg GIT_SHA=${{ needs.get-version.outputs.git_sha }} \
            --build-arg BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
            $NO_CACHE_FLAG \
            ${{ matrix.service.context }}
        else
          docker build \
            -f ${{ matrix.service.dockerfile }} \
            -t ${{ matrix.service.name }}:latest \
            --build-arg BUILD_TIMESTAMP=$BUILD_TIMESTAMP \
            $NO_CACHE_FLAG \
            ${{ matrix.service.context }}
        fi

    - name: Tag and Push ${{ matrix.service.name }} to GHCR
      run: |
        GHCR_IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/${{ matrix.service.name }}"

        # Tag images
        docker tag ${{ matrix.service.name }}:latest ${GHCR_IMAGE_NAME}:latest
        docker tag ${{ matrix.service.name }}:latest ${GHCR_IMAGE_NAME}:${{ needs.get-version.outputs.version }}

        # Push images
        docker push ${GHCR_IMAGE_NAME}:latest
        docker push ${GHCR_IMAGE_NAME}:${{ needs.get-version.outputs.version }}

  build-frontend:
    needs: get-version
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine deployment target
      id: deployment-target
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "target=${{ github.event.inputs.deployment_target }}" >> $GITHUB_OUTPUT
        else
          TARGET="${{ secrets.AWS_DEPLOYMENT_TARGET }}"
          if [ -z "$TARGET" ]; then
            TARGET="aws"
          fi
          echo "target=$TARGET" >> $GITHUB_OUTPUT
        fi

    - name: Log in to GitHub Container Registry
      run: echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    - name: Build and push Frontend image
      run: |
        NO_CACHE_FLAG=""
        if [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
          NO_CACHE_FLAG="--no-cache"
        fi

        # Build frontend (use AWS Dockerfile for AWS, regular for Azure)
        if [ "${{ steps.deployment-target.outputs.target }}" = "aws" ]; then
          docker build -t frontend:latest -f ./ui/Dockerfile.aws $NO_CACHE_FLAG ./ui
        else
          docker build -t frontend:latest -f ./ui/Dockerfile $NO_CACHE_FLAG ./ui
        fi

        # Tag and push (matching working deployment pattern)
        GHCR_IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/frontend"
        docker tag frontend:latest ${GHCR_IMAGE_NAME}:latest
        docker tag frontend:latest ${GHCR_IMAGE_NAME}:${{ needs.get-version.outputs.version }}
        docker push ${GHCR_IMAGE_NAME}:latest
        docker push ${GHCR_IMAGE_NAME}:${{ needs.get-version.outputs.version }}

  deploy:
    needs: [get-version, build-backend, build-frontend]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine deployment target
      id: deployment-target
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "target=${{ github.event.inputs.deployment_target }}" >> $GITHUB_OUTPUT
        else
          TARGET="${{ secrets.AWS_DEPLOYMENT_TARGET }}"
          if [ -z "$TARGET" ]; then
            TARGET="aws"
          fi
          echo "target=$TARGET" >> $GITHUB_OUTPUT
        fi

    - name: Set up environment variables
      run: |
        TARGET="${{ steps.deployment-target.outputs.target }}"
        echo "DEPLOYMENT_TARGET=$TARGET" >> $GITHUB_ENV

        if [ "$TARGET" = "aws" ]; then
          # Use AWS-prefixed secrets
          echo "CLOUD_INSTANCE_IP=${{ secrets.AWS_INSTANCE_IP }}" >> $GITHUB_ENV
          echo "CLOUD_INSTANCE_USER=${{ secrets.AWS_INSTANCE_USER }}" >> $GITHUB_ENV
          echo "JWT_SECRET=${{ secrets.AWS_JWT_SECRET }}" >> $GITHUB_ENV
          echo "ADMIN_PASSWORD=${{ secrets.AWS_ADMIN_PASSWORD }}" >> $GITHUB_ENV
          echo "SERVICE_AUTH_SECRET=${{ secrets.AWS_SERVICE_AUTH_SECRET }}" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=${{ secrets.AWS_CORS_ALLOWED_ORIGINS }}" >> $GITHUB_ENV
          echo "DB_USER=${{ secrets.AWS_DB_USER }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.AWS_DB_PASSWORD }}" >> $GITHUB_ENV
          echo "COMPOSE_ENV=production" >> $GITHUB_ENV
          echo "SWAGGER_API_URL=http://${{ secrets.AWS_INSTANCE_IP }}:8082/swagger.json" >> $GITHUB_ENV
        else
          # Use existing Azure secrets (backward compatibility)
          echo "CLOUD_INSTANCE_IP=${{ secrets.AZURE_VM_HOST }}" >> $GITHUB_ENV
          echo "CLOUD_INSTANCE_USER=${{ secrets.AZURE_VM_USER }}" >> $GITHUB_ENV
          echo "JWT_SECRET=${{ secrets.JWT_SECRET || 'default-jwt-secret' }}" >> $GITHUB_ENV
          echo "ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD || 'admin123' }}" >> $GITHUB_ENV
          echo "SERVICE_AUTH_SECRET=${{ secrets.SERVICE_AUTH_SECRET || 'default-service-secret' }}" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS || 'http://localhost' }}" >> $GITHUB_ENV
          echo "DB_USER=${{ secrets.DB_USER }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          echo "COMPOSE_ENV=${{ secrets.COMPOSE_ENV }}" >> $GITHUB_ENV
          echo "SWAGGER_API_URL=${{ secrets.SWAGGER_API_URL }}" >> $GITHUB_ENV
        fi

        # Set image names (matching working backend-deploy.yml pattern)
        echo "EMPLOYEE_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/employee-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "URGENCY_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/urgency-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "ACTIVITY_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/activity-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "VERSION_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/version-service:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV
        echo "FRONTEND_IMAGE=ghcr.io/${{ github.repository_owner }}/frontend:${{ needs.get-version.outputs.version }}" >> $GITHUB_ENV

    - name: Create secure deployment environment file
      run: |
        cat > .env << EOF
        # Deployment Configuration
        DEPLOYMENT_TARGET=${{ env.DEPLOYMENT_TARGET }}
        CLOUD_INSTANCE_IP=${{ env.CLOUD_INSTANCE_IP }}
        CLOUD_INSTANCE_USER=${{ env.CLOUD_INSTANCE_USER }}
        INSTANCE_IP=${{ env.CLOUD_INSTANCE_IP }}
        INSTANCE_USER=${{ env.CLOUD_INSTANCE_USER }}
        SSH_KEY_PATH=~/.ssh/deploy_key

        # Docker Images
        EMPLOYEE_SERVICE_IMAGE=${{ env.EMPLOYEE_SERVICE_IMAGE }}
        URGENCY_SERVICE_IMAGE=${{ env.URGENCY_SERVICE_IMAGE }}
        ACTIVITY_SERVICE_IMAGE=${{ env.ACTIVITY_SERVICE_IMAGE }}
        VERSION_SERVICE_IMAGE=${{ env.VERSION_SERVICE_IMAGE }}
        FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}

        # GitHub Container Registry Authentication
        GHCR_PAT=${{ secrets.GHCR_PAT }}
        GITHUB_ACTOR=${{ github.actor }}

        # Application Security
        JWT_SECRET=${{ env.JWT_SECRET }}
        ADMIN_PASSWORD=${{ env.ADMIN_PASSWORD }}
        SERVICE_AUTH_SECRET=${{ env.SERVICE_AUTH_SECRET }}
        CORS_ALLOWED_ORIGINS=${{ env.CORS_ALLOWED_ORIGINS }}

        # Database Configuration
        DB_USER=${{ env.DB_USER }}
        DB_PASSWORD=${{ env.DB_PASSWORD }}

        # Service URLs
        EMPLOYEE_SERVICE_URL=http://employee-service:8082
        ACTIVITY_SERVICE_URL=http://activity-service:8084

        # Additional Configuration
        COMPOSE_ENV=${{ env.COMPOSE_ENV }}
        SWAGGER_API_URL=${{ env.SWAGGER_API_URL }}
        EOF

        echo "Secure .env file created with GitHub secrets"

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        if [ "${{ env.DEPLOYMENT_TARGET }}" = "aws" ]; then
          echo "${{ secrets.AWS_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        else
          echo "${{ secrets.AZURE_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        fi
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ env.CLOUD_INSTANCE_IP }} >> ~/.ssh/known_hosts

    - name: Deploy to cloud instance
      run: |
        if [ "${{ env.DEPLOYMENT_TARGET }}" = "aws" ]; then
          export SSH_KEY_CONTENT="${{ secrets.AWS_SSH_PRIVATE_KEY }}"
        else
          export SSH_KEY_CONTENT="${{ secrets.AZURE_SSH_PRIVATE_KEY }}"
        fi
        export SSH_KEY_PATH="~/.ssh/deploy_key"
        
        # Make deployment script executable
        chmod +x ./deploy-aws.sh
        
        # Run deployment
        ./deploy-aws.sh

    - name: Verify deployment
      run: |
        echo "Waiting for services to start..."
        sleep 30

        # Test the application through the frontend/nginx proxy only
        echo "Testing frontend health (main entry point)..."
        curl -f http://${{ env.CLOUD_INSTANCE_IP }}/health || echo "Frontend health check failed"

        # Test general API health through nginx proxy (routes to employee service)
        echo "Testing API health through nginx proxy..."
        curl -f http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/health || echo "API health check through proxy failed"

        # Test version endpoint through nginx proxy
        echo "Testing version API through nginx proxy..."
        curl -f http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/version || echo "Version API through proxy failed"

        # Verify all containers are running (via SSH for debugging)
        echo "Verifying all services are running..."
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ env.CLOUD_INSTANCE_USER }}@${{ env.CLOUD_INSTANCE_IP }} "docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -E '(employee|urgency|activity|version|frontend)'"

        echo "Deployment verification completed successfully!"

    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/deploy_key
        rm -f .env

    - name: Deployment Summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Target Platform**: ${{ env.DEPLOYMENT_TARGET }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Instance**: ${{ env.CLOUD_INSTANCE_USER }}@${{ env.CLOUD_INSTANCE_IP }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Application URL**: http://${{ env.CLOUD_INSTANCE_IP }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Employee API**: http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/employees" >> $GITHUB_STEP_SUMMARY
        echo "- **Urgency API**: http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/urgencies" >> $GITHUB_STEP_SUMMARY
        echo "- **Activity API**: http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/activities" >> $GITHUB_STEP_SUMMARY
        echo "- **Version API**: http://${{ env.CLOUD_INSTANCE_IP }}/api/v1/version" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Architecture**: All API requests are routed through nginx reverse proxy (port 80 only)." >> $GITHUB_STEP_SUMMARY
        echo "**Security**: Backend services (ports 8082-8084, 8090) are not directly accessible externally." >> $GITHUB_STEP_SUMMARY
